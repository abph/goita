<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ごいた 10×10盤面</title>
  <style>
    
    :root{ --gap: 6px; --cell: clamp(28px, calc((100vw - 60px - (9 * var(--gap)))/10), 58px); }
body { font-family: sans-serif; max-width: 1250px; margin: 20px auto; }
    h1 { margin-bottom: 12px; }
    .board-wrap { border: 1px solid #ddd; border-radius: 12px; padding: 12px; }
    .board {
      display: grid;
      grid-template-columns: repeat(10, var(--cell));
      grid-template-rows: repeat(10, var(--cell));
      gap: var(--gap);
      user-select: none;
      margin: 0 auto;
      width: fit-content;
      max-width: 100%;
    }
    .cell {
      border: 1px solid #e6e6e6;
      border-radius: 10px;
      background: #fafafa;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      position: relative;
      overflow: hidden;
    }

    .slot { border: 2px solid #999; background: #fff; font-weight: 600; }
    .slot .val { font-size: 18px; font-weight: 800; }

    .slot.attack { background: #eef6ff; }
    .slot.attack.human { border-color: #4a90e2; background: #eef6ff; }
    .slot.attack.ai    { border-color: #e74c3c; background: #fff2f2; }
    .slot.attack.ai .val { color: #b00000; font-weight: 900; }

    .slot.current-attack {
      background: #cfe8ff;
      border-color: #2b78d6;
      animation: pulse 1.5s infinite;
    }
    .slot.current-attack .val { color: #0b3c7a; font-size: 22px; }
    @keyframes pulse {
      0%   { box-shadow: 0 0 0 0 rgba(43,120,214,0.6); }
      70%  { box-shadow: 0 0 0 10px rgba(43,120,214,0); }
      100% { box-shadow: 0 0 0 0 rgba(43,120,214,0); }
    }

    .hand { border: 2px solid #4a90e2; background: #ffffff; }
    .hand .val { font-size: 18px; font-weight: 900; }
    .hand.clickable { cursor: pointer; }
    .hand.clickable:hover { outline: 3px solid rgba(74,144,226,0.35); }
    .hand.disabled { background: #f0f0f0; border-color: #bbb; color: #999; cursor: not-allowed; }
    .hand.disabled .val { color: #999; }
    .hand.human { border-color: #4a90e2; }
    .hand.ai    { border-color: #e74c3c; }

    .pass {
      border: 3px solid #e74c3c;
      background: #fff2f2;
      cursor: pointer;
      font-weight: 900;
      letter-spacing: 0.5px;
    }
    .pass:hover { background: #ffe7e7; }
    .pass.disabled { opacity: 0.35; cursor: default; }

    .seat-label{
      border: 2px solid #333;
      background: #fff;
      font-weight: 900;
      font-size: 22px;
      letter-spacing: 1px;
    }
    .turn-label{
      border: 2px solid #333;
      background: #fff;
      font-weight: 900;
      font-size: 16px;
      letter-spacing: 0px;
    }

    .phase-label{
      border: 2px solid #333;
      background: #fff;
      font-weight: 900;
      font-size: 14px;
      letter-spacing: 0px;
    }
    .atk-label{
      border: 2px solid #333;
      background: #fff;
      font-weight: 900;
      font-size: 14px;
      letter-spacing: 0px;
    }

    /* ★共有プレイヤー名（9文字/ 1行3文字×3行） */
    .name-label{
      border: 2px solid #333;
      background: #fff;
      font-weight: 900;
      font-size: 12px;
      line-height: 1.15;
      padding: 4px;
      white-space: pre-line;
      text-align: center;
    }

    .ui { margin-top: 14px; border: 1px solid #ddd; border-radius: 12px; padding: 12px; background: #fff; }
    .meta { display: grid; grid-template-columns: 140px 1fr; gap: 6px 10px; font-size: 13px; line-height: 1.5; margin-bottom: 10px; }
    .btns { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-bottom: 10px; }
    button { padding: 7px 10px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button:hover { background: #f6f6f6; }
    select, input[type="text"] { padding: 7px 10px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    select { cursor: pointer; }
    .hint { background:#fff7e6; border: 1px solid #ffd39a; padding: 8px; border-radius: 10px; margin: 10px 0; }
    .small { font-size: 12px; color: #555; }
    .bottom-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 10px; }
    .card { border: 1px solid #e6e6e6; border-radius: 12px; padding: 10px; background: #fafafa; min-height: 120px; }
    pre { background:#f7f7f7; padding:10px; border-radius:10px; max-height: 420px; overflow:auto; margin: 0; }

    .name-grid{
      display: grid;
      grid-template-columns: 80px 15ch 64px;
      gap: 8px 10px;
      align-items: center;
      margin-top: 6px;
      margin-bottom: 6px;
    }

    .name-grid button{
      width: 64px;
      white-space: nowrap;
    }

    /* ★名前入力欄は幅固定（15文字相当） */
    .name-grid input[type="text"]{
      width: 15ch;   /* 半角英数字15文字分 */
      box-sizing: content-box;
    }


    @media (max-width: 980px){
      :root{ --gap: 4px; --cell: clamp(24px, calc((100vw - 40px - (9 * var(--gap)))/10), 52px); }
      body { margin: 10px; }
      .board-wrap { padding: 8px; }
.bottom-grid { grid-template-columns: 1fr; }
      /* スマホでは 1fr にすると3列目（表示ボタン）が右端に飛ぶので、列幅を固定して左詰め */
      .name-grid{
        grid-template-columns: 70px 15ch 56px;
        justify-content: start;
      }
      .name-grid button{
        width: 56px;
      }
    }
  </style>
</head>
<body>
  <h1>ごいた 10×10盤面</h1>

  <div class="board-wrap">
    <div id="board" class="board"></div>
  </div>

  <div class="ui">
    

    <div class="hint" id="handHint">観戦中です。A/B/C/Dを選ぶと操作できます。（PASS：6列目6行目）</div>

    
<div class="meta">
      <b>自分の席</b>
      <span>
        <select id="seatSelect">
          <option value="W">観戦</option>
          <option value="A">A</option>
          <option value="B">B</option>
          <option value="C">C</option>
          <option value="D">D</option>
        </select>
        <span class="small">（観戦→後からA/B/C/Dを選ぶ）</span>
      </span>
    </div>

    <!-- ★共有プレイヤー名入力（サーバに保存） -->
    <div class="name-grid">
      <b>A名前</b><input id="nameA" type="text" maxlength="9" size="15" inputmode="latin" autocomplete="off" placeholder="最大9文字" />
      <button type="button" onclick="applyName('A')">表示</button>

      <b>B名前</b><input id="nameB" type="text" maxlength="9" size="15" inputmode="latin" autocomplete="off" placeholder="最大9文字" />
      <button type="button" onclick="applyName('B')">表示</button>

      <b>C名前</b><input id="nameC" type="text" maxlength="9" size="15" inputmode="latin" autocomplete="off" placeholder="最大9文字" />
      <button type="button" onclick="applyName('C')">表示</button>

      <b>D名前</b><input id="nameD" type="text" maxlength="9" size="15" inputmode="latin" autocomplete="off" placeholder="最大9文字" />
      <button type="button" onclick="applyName('D')">表示</button>
    </div>
    <div class="small">（共有表示。入力後に「表示」を押すと反映。新規ゲームを押すと全員分クリア。表示は 1行3文字×3行）</div>

    <div class="btns" style="margin-top:10px;">
      <button onclick="newGame()">新規ゲーム（main卓リセット）</button>
      <button onclick="refresh()">更新</button>
      <button onclick="toggleAllHands()" id="toggleHandsBtn">みんなの手札を公開</button>
      <button onclick="downloadKifu()">棋譜をダウンロード</button>
      <span class="small">（PASS：6列目6行目）</span>
    </div>
<div class="bottom-grid">
      <div class="card">
        <details>
          <summary><b>（デバッグ用）合法手</b></summary>
          <div class="small">観戦中は空になります。</div>
          <div id="actions" style="margin-top:8px;"></div>
        </details>
      </div>

      <div class="card">
        <div><b>ログ</b></div>
        <pre id="log" style="margin-top:8px;"></pre>
      </div>
    </div>
  </div>

<script>
const API = "";
const MAIN_GID = "main";
let gid = MAIN_GID;

const WATCH = "W";
let mySeat = WATCH;
let lastSeat = "A";

let showAllHands = false;
let latestState = null;
let latestLegal = [];
let pending = null;

const PIECE_LABEL = {"9":"王","8":"玉","7":"飛","6":"角","5":"金","4":"銀","3":"馬","2":"香","1":"し"};
function pieceToLabel(v){ if(!v) return ""; if(v==="■"||v==="□") return v; return PIECE_LABEL[v] ?? v; }
function sortHandNumeric(a){ if(!Array.isArray(a)) return a; return [...a].sort((x,y)=>parseInt(x,10)-parseInt(y,10)); }
function setHint(msg){ document.getElementById("handHint").textContent = msg; }
function key(col,row){ return `${col},${row}`; }
function isSpectator(){ return mySeat === WATCH; }
function viewerSeat(){ return isSpectator() ? "A" : mySeat; }

/** ★共有プレイヤー名（state.player_names を描画に使う） */
function sanitizeName(s){
  s = (s ?? "").toString();
  // 改行だけ除去
  s = s.replace(/\r?\n/g, "");
  // 9文字まで
  if(s.length > 9) s = s.slice(0,9);
  return s;
}


function phaseToJa(p){
  const m = {
    "attack":"攻め",
    "receive":"受け",
    "defense":"受け",
    "block":"受け",
    "end":"終了",
    "finished":"終了"
  };
  if(!p) return "";
  return m[p] || p;
}

function formatNameForBoard(s){
  s = sanitizeName(s);
  if(!s) return "";
  // 1行3文字×3行
  const lines = [];
  for(let i=0;i<s.length && lines.length<3;i+=3){
    lines.push(s.slice(i, i+3));
  }
  return lines.join("\n");
}

const SLOTS = {
  A: { receive:[[4,8],[5,8],[6,8],[7,8]], attack:[[4,9],[5,9],[6,9],[7,9]] },
  C: { receive:[[7,3],[6,3],[5,3],[4,3]], attack:[[7,2],[6,2],[5,2],[4,2]] },
  B: { receive:[[8,7],[8,6],[8,5],[8,4]], attack:[[9,7],[9,6],[9,5],[9,4]] },
  D: { receive:[[3,4],[3,5],[3,6],[3,7]], attack:[[2,4],[2,5],[2,6],[2,7]] },
};
const HAND_POS = {
  A: [[2,10],[3,10],[4,10],[5,10],[6,10],[7,10],[8,10],[9,10]],
  C: [[2,1],[3,1],[4,1],[5,1],[6,1],[7,1],[8,1],[9,1]],
  B: [[10,2],[10,3],[10,4],[10,5],[10,6],[10,7],[10,8],[10,9]],
  D: [[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9]],
};

const PASS_POS = { col: 6, row: 6 };
const SEAT_LABELS = new Map([
  ["3,9", "A"],
  ["9,8", "B"],
  ["8,2", "C"],
  ["2,3", "D"],
]);
const TURN_LABEL_POS = { col: 5, row: 5 };
const PHASE_LABEL_POS = { col: 6, row: 5 };
const ATK_LABEL_POS = { col: 5, row: 6 };

const NAME_POS = {
  A: { col: 8, row: 9 },
  B: { col: 9, row: 3 },
  C: { col: 3, row: 2 },
  D: { col: 2, row: 8 },
};

function buildSlotMap(){
  const m=new Map();
  for(const p of ["A","B","C","D"]){
    SLOTS[p].receive.forEach((c,i)=>m.set(key(c[0],c[1]),{p,kind:"R",idx:i}));
    SLOTS[p].attack.forEach((c,i)=>m.set(key(c[0],c[1]),{p,kind:"A",idx:i}));
  }
  return m;
}
const SLOT_MAP = buildSlotMap();

function buildHandMap(){
  const m=new Map();
  for(const p of ["A","B","C","D"]){
    HAND_POS[p].forEach((c,i)=>m.set(key(c[0],c[1]),{p,idx:i}));
  }
  return m;
}
const HAND_MAP = buildHandMap();

async function claimSeat(seat){
  try{
    await fetch(`${API}/games/main/claim?seat=${encodeURIComponent(seat)}`, {method:"POST"});
  }catch(e){ console.error(e); }
}
async function releaseSeat(seat){
  try{
    await fetch(`${API}/games/main/release?seat=${encodeURIComponent(seat)}`, {method:"POST"});
  }catch(e){ console.error(e); }
}

async function setName(seat, name){
  name = sanitizeName(name);
  try{
    await fetch(`${API}/games/${gid}/set_name`, {
      method:"POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ seat, name })
    });
  }catch(e){ console.error(e); }
}

async function applyName(seat){
  const el = document.getElementById("name" + seat);
  if(!el) return;
  const v = sanitizeName(el.value);
  el.value = v;
  await setName(seat, v);
  // 反映確認のため更新
  await refresh();
}

async function downloadKifu(){
  const res = await fetch(`${API}/games/${gid}/kifu`);
  const text = await res.text();
  const blob = new Blob([text], {type:"text/yaml;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href=url; a.download=`goita_kifu_${String(gid).slice(0,8)}.yaml`;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

function toggleAllHands(){
  showAllHands = !showAllHands;
  document.getElementById("toggleHandsBtn").textContent =
    showAllHands ? "手札表示を戻す" : "みんなの手札を公開";
  refresh();
}

async function submitAction(actionObj){
  await fetch(`${API}/games/${gid}/step`, {
    method:"POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ player: mySeat, action: actionObj })
  });
}

async function onHandPieceClick(piece){
  if(isSpectator()){
    setHint("観戦中は操作できません。A/B/C/Dを選んでください。");
    return;
  }
  if(!latestState) return;
  if(latestState.finished){ setHint("この局は終了しています。（PASS：6列目6行目）"); return; }
  if(latestState.turn !== mySeat){ setHint(`いまは ${latestState.turn} の手番です。（あなた: ${mySeat} / PASS：6列目6行目）`); return; }

  if(pending){
    const matched = pending.candidates.filter(a => pending.need==="attack" ? a.attack===piece : a.block===piece);
    if(matched.length === 1){
      await submitAction(matched[0]);
      pending = null;
      await refresh();
      return;
    }
    if(matched.length > 1){
      setHint("同じ駒で複数候補があります。デバッグ用ボタンから選んでください。");
      return;
    }
    setHint("その駒は選べません。");
    return;
  }

  const candidates = latestLegal.filter(a => (a.block === piece) || (a.attack === piece));
  if(candidates.length === 0){ setHint("その駒は今は出せません。（PASS：6列目6行目）"); return; }

  if(candidates.length === 1){
    await submitAction(candidates[0]);
    await refresh();
    return;
  }

  const aab = candidates.filter(a => a.action_type === "attack_after_block");
  const asBlock = aab.filter(a => a.block === piece);
  if(asBlock.length >= 1){
    pending = { need: "attack", candidates: asBlock };
    setHint(`伏せに ${pieceToLabel(piece)}。次に攻めを選んでください。（PASS：6列目6行目）`);
    return;
  }
  const asAttack = aab.filter(a => a.attack === piece);
  if(asAttack.length >= 1){
    pending = { need: "block", candidates: asAttack };
    setHint(`攻めに ${pieceToLabel(piece)}。次に伏せを選んでください。（PASS：6列目6行目）`);
    return;
  }

  setHint("複数候補があり確定できません。デバッグ用ボタンから選んでください。");
}

async function onPassClick(){
  if(isSpectator()){
    setHint("観戦中は操作できません。A/B/C/Dを選んでください。");
    return;
  }
  if(!latestState) return;
  if(latestState.finished){ setHint("この局は終了しています。（PASS：6列目6行目）"); return; }
  if(latestState.turn !== mySeat){ setHint(`いまは ${latestState.turn} の手番です。（あなた: ${mySeat} / PASS：6列目6行目）`); return; }

  const pass = latestLegal.find(a => a.action_type === "pass");
  if(!pass){ setHint("今はパスできません。（PASS：6列目6行目）"); return; }

  pending = null;
  await submitAction(pass);
  await refresh();
}

function seatIsHuman(state, seat){
  const hs = state?.human_seats;
  if(Array.isArray(hs)) return hs.includes(seat);
  return seat === mySeat;
}

function renderBoard(state){
  const board=document.getElementById("board");
  board.innerHTML="";

  const usable = new Set();
  if(!isSpectator() && state.turn===mySeat && !state.finished){
    if(pending && pending.candidates){
      pending.candidates.forEach(a => {
        if(pending.need==="attack" && a.attack) usable.add(a.attack);
        if(pending.need==="block" && a.block) usable.add(a.block);
      });
    }else{
      latestLegal.forEach(a => { if(a.block) usable.add(a.block); if(a.attack) usable.add(a.attack); });
    }
  }

  const names = state.player_names || {A:"",B:"",C:"",D:""};

  for(let row=1;row<=10;row++){
    for(let col=1;col<=10;col++){
      const div=document.createElement("div");
      div.className="cell";
      div.style.gridColumn=col; div.style.gridRow=row;

      const k = key(col,row);

      if(col===PASS_POS.col && row===PASS_POS.row){
        div.classList.add("pass");
        div.textContent="PASS";
        if(!isSpectator() && state.turn===mySeat && !state.finished && latestLegal.some(a=>a.action_type==="pass")){
          div.onclick=onPassClick;
        }else{
          div.classList.add("disabled");
        }
        board.appendChild(div);
        continue;
      }

      if(col===TURN_LABEL_POS.col && row===TURN_LABEL_POS.row){
        div.classList.add("turn-label");
        div.textContent = `手番${state.turn || ""}`;
        board.appendChild(div);
        continue;
      }

      if(col===PHASE_LABEL_POS.col && row===PHASE_LABEL_POS.row){
        div.classList.add("phase-label");
        div.textContent = phaseToJa(state.phase);
        board.appendChild(div);
        continue;
      }

      if(col===ATK_LABEL_POS.col && row===ATK_LABEL_POS.row){
        div.classList.add("atk-label");
        const atk = state.attacker || "";
        const ca = state.current_attack ? pieceToLabel(state.current_attack) : "";
        div.textContent = (atk && ca) ? `${atk}${ca}` : "";
        board.appendChild(div);
        continue;
      }

      // ★プレイヤー名表示（共有）
      let placedName = false;
      for(const s of ["A","B","C","D"]){
        const pos = NAME_POS[s];
        if(pos.col === col && pos.row === row){
          div.classList.add("name-label");
          div.textContent = formatNameForBoard(names[s] || "");
          board.appendChild(div);
          placedName = true;
          break;
        }
      }
      if(placedName) continue;

      const label = SEAT_LABELS.get(k);
      if(label){
        div.classList.add("seat-label");
        div.textContent = label;
        board.appendChild(div);
        continue;
      }

      const hand=HAND_MAP.get(k);
      if(hand){
        div.classList.add("hand");
        div.classList.add(seatIsHuman(state, hand.p) ? "human" : "ai");

        const val=document.createElement("div");
        val.className="val";

        const canShowSeat = (!isSpectator() && hand.p===mySeat) || showAllHands;

        if(canShowSeat){
          const raw = state.hands?.[hand.p];
          const arr = sortHandNumeric(raw);
          const card = Array.isArray(arr) ? arr[hand.idx] : null;
          val.textContent = card ? pieceToLabel(card) : "□";

          if(!isSpectator() && hand.p===mySeat && state.turn===mySeat && !state.finished && card){
            if(usable.has(card)){
              div.classList.add("clickable");
              div.onclick = () => onHandPieceClick(card);
            }else{
              div.classList.add("disabled");
            }
          }
        }else{
          val.textContent="□";
        }

        div.appendChild(val);
        board.appendChild(div);
        continue;
      }

      const slot=SLOT_MAP.get(k);
      if(slot){
        div.classList.add("slot");

        if(slot.kind==="A"){
          div.classList.add("attack");
          div.classList.add(seatIsHuman(state, slot.p) ? "human" : "ai");
        }

        const val=document.createElement("div");
        val.className="val";
        const kindKey = slot.kind==="R" ? "receive" : "attack";
        const piece = state.board_public?.[slot.p]?.[kindKey]?.[slot.idx];

        if(piece){
          if(kindKey==="receive"){
            const hidden = state.board_public?.[slot.p]?.receive_hidden?.[slot.idx];
            val.textContent = hidden ? "■" : pieceToLabel(piece);
          }else{
            val.textContent = pieceToLabel(piece);
          }
        }
        div.appendChild(val);
      }

      board.appendChild(div);
    }
  }
}

async function renderActions(){
  const actionsDiv = document.getElementById("actions");
  actionsDiv.innerHTML="";
  if(isSpectator()) return;

  latestLegal.forEach(a=>{
    const btn=document.createElement("button");
    const t=a.action_type;
    const b=a.block ? pieceToLabel(a.block) : "";
    const at=a.attack ? pieceToLabel(a.attack) : "";
    btn.textContent = `${t} ${b} ${at}`.trim();
    btn.onclick = async ()=>{ pending=null; await submitAction(a); await refresh(); };
    actionsDiv.appendChild(btn);
  });
}

async function newGame(){
  await fetch(`${API}/games/main/reset`, {method:"POST"});
  pending=null; showAllHands=false;
  document.getElementById("toggleHandsBtn").textContent="みんなの手札を公開";
  await refresh();
}

async function fetchLegal(){
  if(isSpectator()) return [];
  const res = await fetch(`${API}/games/${gid}/legal_actions?player=${encodeURIComponent(mySeat)}`);
  const acts = await res.json();
  return Array.isArray(acts) ? acts : [];
}

async function refresh(){
  const qs = new URLSearchParams();
  qs.set("viewer", viewerSeat());
  if(showAllHands) qs.set("reveal_hands","1");

  const state = await (await fetch(`${API}/games/${gid}/state?${qs.toString()}`)).json();
  latestState = state;
  document.getElementById("log").textContent = (state.log||[]).join("\n");

  latestLegal = await fetchLegal();

  if(state.finished){
    setHint(`この局は終了しました（勝者: ${state.winner}）。新規ゲームを押してください。（PASS：6列目6行目）`);
    pending = null;
  }else if(isSpectator()){
    setHint("観戦中です。A/B/C/Dを選ぶと操作できます。（PASS：6列目6行目）");
    pending = null;
  }else if(state.turn !== mySeat){
    setHint(`いまは ${state.turn} の手番です。（あなた: ${mySeat} / PASS：6列目6行目）`);
    pending = null;
  }else if(!pending){
    setHint("あなたの手番です。手札をクリックしてください。（PASS：6列目6行目）");
  }

  renderBoard(state);
  await renderActions();
}

function bindNameInputs(){
  const ids = ["nameA","nameB","nameC","nameD"];
  for(const id of ids){
    const el = document.getElementById(id);
    if(!el) continue;
    el.addEventListener("input", ()=>{
      const v = sanitizeName(el.value);
      if(el.value !== v) el.value = v;
    });
  }
}

window.addEventListener("load", async ()=>{
  bindNameInputs();

  const sel = document.getElementById("seatSelect");
  mySeat = WATCH;
  sel.value = WATCH;

  await refresh();

  sel.addEventListener("change", async ()=>{
    const next = sel.value;

    if(!isSpectator()){
      await releaseSeat(lastSeat);
    }

    pending = null;

    if(next === WATCH){
      mySeat = WATCH;
      sel.value = WATCH;
      await refresh();
      return;
    }

    mySeat = next;
    lastSeat = mySeat;
    await claimSeat(mySeat);
    await refresh();
  });

  setInterval(refresh, 2000);
});
</script>
</body>
</html>
