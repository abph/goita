<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>ごいた 10×10盤面</title>
  <style>
    body { font-family: sans-serif; max-width: 1250px; margin: 20px auto; }
    h1 { margin-bottom: 12px; }

    .board-wrap { border: 1px solid #ddd; border-radius: 12px; padding: 12px; }

    .board {
      display: grid;
      grid-template-columns: repeat(10, 58px);
      grid-template-rows: repeat(10, 58px);
      gap: 6px;
      user-select: none;
      margin: 0 auto;
    }
    .cell {
      border: 1px solid #e6e6e6;
      border-radius: 10px;
      background: #fafafa;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      position: relative;
    }

    .slot { border: 2px solid #999; background: #fff; font-weight: 600; }
    .slot .val { font-size: 18px; font-weight: 800; }

    .hand { border: 2px solid #4a90e2; background: #ffffff; }
    .hand .val { font-size: 18px; font-weight: 900; }

    .hand.clickable { cursor: pointer; }
    .hand.clickable:hover { outline: 3px solid rgba(74,144,226,0.35); }
    .hand.selected { outline: 4px solid rgba(255,140,0,0.55); }

    

    /* ★追加：今は使えない手札（うす暗い灰色） */
    .hand.disabled {
      background: #f0f0f0;
      border-color: #bbb;
      color: #999;
      cursor: not-allowed;
    }
    .hand.disabled .val { color: #999; }
/* 攻め（attack）マスを薄い青に */
    .slot.attack {
      background: #eef6ff;   /* とても薄い青 */
    }

    
    /* ===== current_attack 強調 ===== */
    .slot.current-attack {
      background: #cfe8ff;      /* 少し濃い青 */
      border-color: #2b78d6;
      animation: pulse 1.5s infinite;
    }
    .slot.current-attack .val {
      color: #0b3c7a;
      font-size: 22px;
    }

    @keyframes pulse {
      0%   { box-shadow: 0 0 0 0 rgba(43,120,214,0.6); }
      70%  { box-shadow: 0 0 0 10px rgba(43,120,214,0); }
      100% { box-shadow: 0 0 0 0 rgba(43,120,214,0); }
    }
/* PASSセル */
    .pass {
      border: 3px solid #e74c3c;
      background: #fff2f2;
      cursor: pointer;
      font-weight: 900;
      letter-spacing: 0.5px;
    }
    .pass:hover { background: #ffe7e7; }
    .pass.disabled { opacity: 0.35; cursor: default; }

    /* 下部UI */
    .ui {
      margin-top: 14px;
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 12px;
      background: #fff;
    }

    .meta {
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 6px 10px;
      font-size: 13px;
      line-height: 1.5;
      margin-bottom: 10px;
    }
    .meta b { display: inline-block; }

    .btns { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; margin-bottom: 10px; }
    button { padding: 7px 10px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button:hover { background: #f6f6f6; }

    .hint { background:#fff7e6; border: 1px solid #ffd39a; padding: 8px; border-radius: 10px; margin: 10px 0; }
    .small { font-size: 12px; color: #555; }

    .bottom-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 10px;
    }

    .card {
      border: 1px solid #e6e6e6;
      border-radius: 12px;
      padding: 10px;
      background: #fafafa;
      min-height: 120px;
    }

    pre { background:#f7f7f7; padding:10px; border-radius:10px; max-height: 420px; overflow:auto; margin: 0; }

    /* スマホ等で縦に */
    @media (max-width: 980px){
      .bottom-grid { grid-template-columns: 1fr; }
      .board { transform: scale(0.92); transform-origin: top center; }
    }
  </style>
</head>
<body>
  <h1>ごいた 10×10盤面</h1>

  <div class="board-wrap">
    <div id="board" class="board"></div>
  </div>

  <div class="ui">
    <div class="meta">
      <b>あなたの席</b><span><select id="seatSel"><option value="A">A</option><option value="B">B</option><option value="C">C</option><option value="D">D</option></select></span><b>game_id</b><span id="gid">-</span>
      <b>turn</b><span id="turn">-</span>
      <b>phase</b><span id="phase">-</span>
      <b>attacker</b><span id="attacker">-</span>
      <b>current_attack</b><span id="current_attack">-</span>
    </div>

    <div class="btns">
      <button onclick="newGame()">新規ゲーム</button>
            <button onclick="passNow()" id="passBtn">PASS</button>
      <button onclick="refresh()">更新</button>
      <button onclick="toggleAllHands()" id="toggleHandsBtn">みんなの手札を公開</button>
      <button onclick="downloadKifu()">棋譜をダウンロード</button>
      <span class="small">（PASS：盤面の 8列目9行目）</span>
    </div>

    <div class="hint" id="handHint">手札をクリックして駒を出します。</div>

    <div class="bottom-grid">
      <div class="card">
        <details>
          <summary><b>（デバッグ用）合法手</b></summary>
          <div class="small">手札クリックがうまくいかない時の保険です。</div>
          <div id="actions" style="margin-top:8px;"></div>
        </details>
      </div>

      <div class="card">
        <div><b>ログ</b></div>
        <pre id="log" style="margin-top:8px;"></pre>
      </div>
    </div>
  </div>

<script>
const API = "";

async function downloadKifu(){
  if(!gid){
    alert("先に「新規ゲーム」を開始してください。");
    return;
  }
  try{
    // /kifu は YAML テキストを返す想定
    const res = await fetch(`${API}/games/${gid}/kifu`);
    if(!res.ok){
      const t = await res.text();
      alert(`棋譜取得に失敗しました: ${res.status}\n${t}`);
      return;
    }
    const text = await res.text();
    const blob = new Blob([text], {type: "text/yaml;charset=utf-8"});
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    // ファイル名：game_idの先頭を使って短く
    const shortId = String(gid).slice(0, 8);
    a.href = url;
    a.download = `goita_kifu_${shortId}.yaml`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }catch(e){
    console.error(e);
    alert("棋譜ダウンロード中にエラーが発生しました。コンソールも確認してください。");
  }
}

let gid = "main";
let mySeat = "A";
let showAllHands = false;
let pollTimer = null;

// 最新の状態と合法手（手札クリックで使う）
let latestState = null;
let latestLegal = [];

// 2段階選択（attack_after_block）用
let pending = null; // { need: "attack"|"block", fixedPiece: "8", fixedRole:"block"|"attack", candidates:[actions...] }

function key(col,row){ return `${col},${row}`; }

// ====== 駒表示変換 ======
const PIECE_LABEL = {
  "9": "王","8": "玉","7": "飛","6": "角",
  "5": "金","4": "銀","3": "馬","2": "香","1": "し",
};
function pieceToLabel(v){
  if (!v) return "";
  if (v === "■" || v === "□") return v;
  return PIECE_LABEL[v] ?? v;
}

// ====== 手札を 1→9 に並べ替える ======
function sortHandNumeric(handArr){
  if(!Array.isArray(handArr)) return handArr;
  return [...handArr].sort((a,b)=>parseInt(a,10)-parseInt(b,10));
}

function setHint(msg){
  document.getElementById("handHint").textContent = msg;
}

// ====== 受け/攻めスロット ======
const SLOTS = {
  A: { receive:[[4,8],[5,8],[6,8],[7,8]], attack:[[4,9],[5,9],[6,9],[7,9]] },
  C: { receive:[[7,3],[6,3],[5,3],[4,3]], attack:[[7,2],[6,2],[5,2],[4,2]] },
  B: { receive:[[8,7],[8,6],[8,5],[8,4]], attack:[[9,7],[9,6],[9,5],[9,4]] },
  D: { receive:[[3,4],[3,5],[3,6],[3,7]], attack:[[2,4],[2,5],[2,6],[2,7]] },
};

const HAND_POS = {
  A: [[2,10],[3,10],[4,10],[5,10],[6,10],[7,10],[8,10],[9,10]],
  C: [[2,1],[3,1],[4,1],[5,1],[6,1],[7,1],[8,1],[9,1]],
  B: [[10,2],[10,3],[10,4],[10,5],[10,6],[10,7],[10,8],[10,9]],
  D: [[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9]],
};

function buildSlotMap(){
  const m=new Map();
  for(const p of ["A","B","C","D"]){
    SLOTS[p].receive.forEach((c,i)=>m.set(key(c[0],c[1]),{p,kind:"R",idx:i}));
    SLOTS[p].attack.forEach((c,i)=>m.set(key(c[0],c[1]),{p,kind:"A",idx:i}));
  }
  return m;
}
const SLOT_MAP = buildSlotMap();

function buildHandMap(){
  const m=new Map();
  for(const p of ["A","B","C","D"]){
    HAND_POS[p].forEach((c,i)=>m.set(key(c[0],c[1]),{p,idx:i}));
  }
  return m;
}
const HAND_MAP = buildHandMap();

function toggleAllHands(){
  showAllHands = !showAllHands;
  document.getElementById("toggleHandsBtn").textContent =
    showAllHands ? "手札表示を戻す" : "みんなの手札を公開";
  refresh();
}

// ====== 手札クリック処理 ======
async function onHandPieceClick(piece){
  if(!gid || !latestState) return;

  if(latestState.finished){
    setHint("この局は終了しています。新規ゲームを開始してください。");
    return;
  }
  if(latestState.turn !== mySeat){
    setHint(`いまは ${latestState.turn} の手番です。`);
    return;
  }

  // 2段階選択中の場合
  if(pending){
    const matched = pending.candidates.filter(a => {
      if(pending.need === "attack") return a.attack === piece;
      if(pending.need === "block") return a.block === piece;
      return false;
    });

    if(matched.length === 1){
      await submitAction(matched[0]);
      pending = null;
      await refresh();
      return;
    }else if(matched.length > 1){
      setHint("同じ駒で複数候補があります。デバッグ用ボタンから選んでください。");
      return;
    }else{
      setHint(`その駒は選べません。${pending.need === "attack" ? "攻め" : "受け"}の駒をもう一度選んでください。`);
      return;
    }
  }

  const candidates = latestLegal.filter(a => (a.block === piece) || (a.attack === piece));
  if(candidates.length === 0){
    setHint("その駒は今は出せません（合法手にありません）。");
    return;
  }

  if(candidates.length === 1){
    await submitAction(candidates[0]);
    await refresh();
    return;
  }

  const aab = candidates.filter(a => a.action_type === "attack_after_block");

  const asBlock = aab.filter(a => a.block === piece);
  if(asBlock.length >= 1){
    pending = { need: "attack", fixedPiece: piece, fixedRole: "block", candidates: asBlock };
    setHint(`伏せ（受け）に ${pieceToLabel(piece)} を選びました。次に「攻め」の駒をクリックしてください。`);
    return;
  }

  const asAttack = aab.filter(a => a.attack === piece);
  if(asAttack.length >= 1){
    pending = { need: "block", fixedPiece: piece, fixedRole: "attack", candidates: asAttack };
    setHint(`攻めに ${pieceToLabel(piece)} を選びました。次に「伏せ（受け）」の駒をクリックしてください。`);
    return;
  }

  setHint("この駒は複数の出し方があり、確定できません。デバッグ用ボタンから選んでください。");
}

// ====== PASS処理 ======
async function onPassClick(){
  if(!gid || !latestState) return;

  if(latestState.finished){
    setHint("この局は終了しています。新規ゲームを開始してください。");
    return;
  }
  if(latestState.turn !== mySeat){
    setHint(`いまは ${latestState.turn} の手番です。`);
    return;
  }

  const pass = latestLegal.find(a => a.action_type === "pass");
  if(!pass){
    setHint("今はパスできません（合法手にpassがありません）。");
    return;
  }

  pending = null;
  await submitAction(pass);
  await refresh();
}

// ====== API送信 ======
async function submitAction(actionObj){
  await fetch(`${API}/games/${gid}/step`, {
    method:"POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({action: actionObj})
  });
}

// ====== 盤面描画 ======
function renderBoard(state){
  const board=document.getElementById("board");
  board.innerHTML="";

  // ★ Aが今「使える駒」の集合（pending中は pending を優先）
  const usablePiecesMe = new Set();
  if(state.turn === mySeat && !state.finished){
    if(pending && Array.isArray(pending.candidates)){
      // 2段階選択中：次に必要な種類（attack / block）の候補だけ使える扱い
      pending.candidates.forEach(a => {
        if(pending.need === "attack" && a.attack) usablePiecesMe.add(a.attack);
        if(pending.need === "block" && a.block) usablePiecesMe.add(a.block);
      });
    }else if(Array.isArray(latestLegal)){
      // 通常：合法手に出てくる block/attack のいずれかが含まれていれば「使える」
      latestLegal.forEach(a => {
        if(a.block) usablePiecesMe.add(a.block);
        if(a.attack) usablePiecesMe.add(a.attack);
      });
    }
  }

  for(let row=1;row<=10;row++){
    for(let col=1;col<=10;col++){
      const div=document.createElement("div");
      div.className="cell";
      div.style.gridColumn=col;
      div.style.gridRow=row;

      // PASSセル：8列目9行目
      if(col===8 && row===9){
        div.classList.add("pass");
        div.textContent = "PASS";
        if(false){
          div.onclick = onPassClick;
        }else{
          div.classList.add("disabled");
          div.onclick = null;
        }
        board.appendChild(div);
        continue;
      }

      const k=key(col,row);

      // 手札セル
      const hand=HAND_MAP.get(k);
      if(hand){
        div.classList.add("hand");
        const val=document.createElement("div");
        val.className="val";

        if(hand.p===mySeat || showAllHands){
          const raw = state.hands?.[hand.p];
          const arr = sortHandNumeric(raw);
          const card = Array.isArray(arr) ? arr[hand.idx] : null;

          val.textContent = card ? pieceToLabel(card) : "□";

          if(hand.p===mySeat && state.turn===mySeat && !state.finished && card){
            if(usablePiecesMe.has(card)){
              div.classList.add("clickable");
              div.onclick = () => onHandPieceClick(card);
            }else{
              div.classList.add("disabled");
              div.onclick = null;
            }
          }else{
            div.onclick = null;
          }
}else{
          val.textContent="□";
          div.onclick = null;
        }

        div.appendChild(val);
        board.appendChild(div);
        continue;
      }

      // 受け/攻めスロット
      const slot=SLOT_MAP.get(k);
      if(slot){
        div.classList.add("slot");
        if(slot.kind === "A") div.classList.add("attack");
        const val=document.createElement("div");
        val.className="val";

        const kindKey = slot.kind==="R"?"receive":"attack";
        const piece = state.board_public?.[slot.p]?.[kindKey]?.[slot.idx];
        // ★ current_attack は「最新の攻め1枚」だけ光らせる（同じ駒が複数並んでも最新のみ）
        if (slot.kind === "A" && state.current_attack && state.attacker) {
          const atkP = state.attacker;

          // attacker の攻め配列から「最後に置かれた index」を取得
          const atkArr = state.board_public?.[atkP]?.attack || [];
          let lastIdx = -1;
          for (let i = atkArr.length - 1; i >= 0; i--) {
            if (atkArr[i] != null) { lastIdx = i; break; }
          }

          // attacker かつ 最新 index のマスだけを強調
          if (
            slot.p === atkP &&
            slot.idx === lastIdx &&
            piece === state.current_attack
          ) {
            div.classList.add("current-attack");
          }
        }


        if(piece){
          if(kindKey==="receive"){
            const hidden=state.board_public?.[slot.p]?.receive_hidden?.[slot.idx];
            val.textContent = hidden ? "■" : pieceToLabel(piece);
          }else{
            val.textContent = pieceToLabel(piece);
          }
        }
        div.appendChild(val);
      }

      board.appendChild(div);
    }
  }
}

// ====== デバッグ用：合法手ボタン表示 ======
async function renderActions(){
  const actionsDiv = document.getElementById("actions");
  actionsDiv.innerHTML = "";
  if (!gid) return;

  latestLegal.forEach(a => {
    const t = a.action_type;
    const b = a.block ? pieceToLabel(a.block) : "";
    const at = a.attack ? pieceToLabel(a.attack) : "";
    const label = `${t} ${b} ${at}`.trim();

    const btn = document.createElement("button");
    btn.textContent = label;
    btn.onclick = async () => {
      pending = null;
      await submitAction(a);
      await refresh();
    };
    actionsDiv.appendChild(btn);
  });
}

async function newGame(){
  // 常設卓をリセット（全員が同じ卓を参照します）
  mySeat = document.getElementById("seatSel").value;
  await fetch(`${API}/games/${gid}/reset?dealer=A`, {method:"POST"});
  pending = null;
  setHint("新しい局を開始しました。5秒ごとに更新します。");
  await refresh();
  startPolling();
}

function startPolling(){
  stopPolling();
  pollTimer = setInterval(()=>{ refresh(); }, 5000);
}
function stopPolling(){
  if(pollTimer){ clearInterval(pollTimer); pollTimer = null; }
}

async function passNow(){
  if(!gid || !latestState) return;
  if(latestState.finished){
    setHint("この局は終了しています。");
    return;
  }
  if(latestState.turn !== mySeat){
    setHint(`いまは ${latestState.turn} の手番です。`);
    return;
  }
  const pass = latestLegal.find(a => a.action_type === "pass");
  if(!pass){
    setHint("今はパスできません。");
    return;
  }
  pending = null;
  await submitAction(pass);
  await refresh();
}

async function fetchLegal(){
  if(!gid) return [];
  const acts = await (await fetch(`${API}/games/${gid}/legal_actions`)).json();
  return Array.isArray(acts) ? acts : [];
}

async function refresh(){
  if(!gid) return;

  let url = `${API}/games/${gid}/state?seat=${encodeURIComponent(mySeat)}`;
  if(showAllHands){ url += `&reveal_hands=1`; }
  if(showAllHands){
    url += `&reveal_hands=1` + (adminToken ? `&admin=${encodeURIComponent(adminToken)}` : ``);
  }
  const state = await (await fetch(url)).json();
  latestState = state;

  document.getElementById("turn").textContent = state.turn;
  document.getElementById("phase").textContent = state.phase;
  document.getElementById("attacker").textContent = state.attacker || "";
  document.getElementById("current_attack").textContent =
    state.current_attack ? pieceToLabel(state.current_attack) : "";

  document.getElementById("log").textContent = (state.log||[]).join("\n");

  // 合法手を更新（手札クリック＆PASSが参照）
  latestLegal = await fetchLegal();

  // PASSボタン有効/無効
  const passBtn = document.getElementById("passBtn");
  if(passBtn){
    const canPass = (state.turn===mySeat && !state.finished && latestLegal.some(a=>a.action_type==="pass"));
    passBtn.disabled = !canPass;
  }

  // ヒント更新
  if(state.finished){
    setHint(`この局は終了しました（勝者: ${state.winner}）。新規ゲームを押してください。`);
    pending = null;
  }else if(state.turn !== "A"){
    setHint(`いまは ${state.turn} の手番です。待ってください。`);
    pending = null;
  }else if(pending){
    // pending中は維持
  }else{
    if(state.phase === "receive"){
      setHint("受けの駒を、手札からクリックしてください。（PASS：8列目9行目）");
    }else if(state.phase === "attack"){
      setHint("攻めの駒を、手札からクリックしてください。（PASS：8列目9行目）");
    }else{
      setHint("手札をクリックして駒を出します。（PASS：8列目9行目）");
    }
  }

  renderBoard(state);
  await renderActions();
}
function initSingleTable(){
  const saved = localStorage.getItem("goita_seat");
  if(saved){
    mySeat = saved;
    const sel = document.getElementById("seatSel");
    if(sel) sel.value = saved;
  }
  const sel = document.getElementById("seatSel");
  if(sel){
    sel.addEventListener("change", ()=>{
      mySeat = sel.value;
      localStorage.setItem("goita_seat", mySeat);
      refresh();
    });
  }
  refresh();
  startPolling();
}
window.addEventListener("load", initSingleTable);

</script>
</body>
</html>
